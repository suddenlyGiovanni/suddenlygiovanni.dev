import process from 'node:process'

import { createReadableStreamFromReadable, writeReadableStreamToWritable } from '@react-router/node'
import type * as express from 'express'
import type { AppLoadContext, ServerBuild } from 'react-router'
import { createRequestHandler as createRemixRequestHandler } from 'react-router'

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by Express middleware like `req.session`.
 */
export type GetLoadContextFunction = (
	req: express.Request,
	res: express.Response,
) => Promise<AppLoadContext> | AppLoadContext

export type RequestHandler = (
	req: express.Request,
	res: express.Response,
	next: express.NextFunction,
) => Promise<void>

/**
 * Creates and returns an Express request handler that utilizes Remix to process HTTP requests.
 *
 * This function constructs an asynchronous request handler that:
 * - Converts the incoming Express request and response into a Remix Request.
 * - Optionally retrieves a load context via the provided getLoadContext callback.
 * - Processes the Remix request using the supplied ServerBuild (or a function returning one) and mode.
 * - Sends the resulting Remix response back to the Express response object.
 *
 * In the event of an error, the handler passes the error to Express's error handling middleware.
 *
 * @param build - A ServerBuild instance or a function that returns a Promise resolving to a ServerBuild, providing the server's configuration.
 * @param getLoadContext - An optional function that extracts the load context from the Express request and response.
 * @param mode - The operating mode (e.g., "development" or "production"). Defaults to process.env['NODE_ENV'].
 *
 * @returns An Express request handler function for processing requests with Remix.
 *
 * @example
 * const handler = createRequestHandler({
 *   build: myServerBuild,
 *   getLoadContext: (req, res) => ({ user: req.user }),
 *   mode: 'development',
 * });
 * app.use(handler);
 */
export function createRequestHandler({
	build,
	getLoadContext,
	mode = process.env['NODE_ENV'],
}: {
	build: ServerBuild | (() => Promise<ServerBuild>)
	getLoadContext?: GetLoadContextFunction
	mode?: ('development' | 'production') | (string & {})
}): RequestHandler {
	const handleRequest = createRemixRequestHandler(build, mode)

	return async (
		req: express.Request,
		res: express.Response,
		next: express.NextFunction,
	): Promise<void> => {
		try {
			const request = createRemixRequest(req, res)
			const loadContext = await getLoadContext?.(req, res)

			const response = await handleRequest(request, loadContext)

			await sendRemixResponse(res, response)
		} catch (error: unknown) {
			// Express doesn't support async functions, so we have to pass along the
			// error manually using next().
			next(error)
		}
	}
}

export function createRemixHeaders<RequestHeaders extends express.Request['headers']>(
	requestHeaders: RequestHeaders,
): Headers {
	const headers = new Headers()

	for (const [key, values] of Object.entries(requestHeaders)) {
		if (values) {
			if (Array.isArray(values)) {
				for (const value of values) {
					headers.append(key, value)
				}
			} else {
				headers.set(key, values)
			}
		}
	}

	return headers
}

export function createRemixRequest<Req extends express.Request, Res extends express.Response>(
	req: Req,
	res: Res,
): Request {
	/**
	 * req.hostname doesn't include port information so grab that from
	 * `X-Forwarded-Host` or `Host`
	 */
	const [, hostnamePort] = req.get('X-Forwarded-Host')?.split(':') ?? []
	const [, hostPort] = req.get('host')?.split(':') ?? []
	const port = hostnamePort || hostPort
	// Use req.hostname here as it respects the "trust proxy" setting
	const resolvedHost = `${req.hostname}${port ? `:${port}` : ''}`
	// Use `req.originalUrl` so Remix is aware of the full path
	const url = new URL(`${req.protocol}://${resolvedHost}${req.originalUrl}`)

	// Abort action/loaders once we can no longer write a response
	let controller: AbortController | null = new AbortController()
	const init: RequestInit = {
		method: req.method,
		headers: createRemixHeaders(req.headers),
		signal: controller.signal,
	}

	/**
	 * Abort action/loaders once we can no longer write a response iff we have not yet sent a response
	 * (i.e., `close` without `finish`)
	 * `finish` -> done rendering the response
	 * `close` -> response can no longer be written to
	 */
	res.on('finish', () => {
		controller = null
	})

	res.on('close', () => {
		controller?.abort()
	})

	if (req.method !== 'GET' && req.method !== 'HEAD') {
		init.body = createReadableStreamFromReadable(req)
		;(init as { duplex: 'half' }).duplex = 'half'
	}

	return new Request(url.href, init)
}

export async function sendRemixResponse<
	ExpressResponse extends express.Response,
	NodeResponse extends Response,
>(res: ExpressResponse, nodeResponse: NodeResponse): Promise<void> {
	res.statusMessage = nodeResponse.statusText
	res.status(nodeResponse.status)

	for (const [key, value] of nodeResponse.headers.entries()) {
		res.append(key, value)
	}

	if (nodeResponse.headers.get('Content-Type')?.match(/text\/event-stream/i)) {
		res.flushHeaders()
	}

	if (nodeResponse.body) {
		await writeReadableStreamToWritable(nodeResponse.body, res)
	} else {
		res.end()
	}
}
